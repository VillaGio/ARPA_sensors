// ============================================================================
//
// Copyright (c) 2006-2015, Talend Inc.
//
// This source code has been automatically generated by_Talend Open Studio for Data Integration
// / Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


package arpa_data.combinesplittedcsv_0_1;

import routines.Numeric;
import routines.DataOperation;
import routines.TalendDataGenerator;
import routines.TalendStringUtil;
import routines.TalendString;
import routines.StringHandling;
import routines.Relational;
import routines.TalendDate;
import routines.Mathematical;
import routines.system.*;
import routines.system.api.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.math.BigDecimal;
import java.io.ByteArrayOutputStream;
import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.IOException;
import java.util.Comparator;
 





@SuppressWarnings("unused")

/**
 * Job: combineSplittedCsv Purpose: <br>
 * Description: Combines together into one csv file the different bulk csv files generated from the splitted files obtained in splitCsvBulk.
This is necessary to run integrity checks between data stored in the database and data stored in the original csv file. <br>
 * @author user@talend.com
 * @version 8.0.1.20211109_1610
 * @status 
 */
public class combineSplittedCsv implements TalendJob {

protected static void logIgnoredError(String message, Throwable cause) {
       System.err.println(message);
       if (cause != null) {
               cause.printStackTrace();
       }

}


	public final Object obj = new Object();

	// for transmiting parameters purpose
	private Object valueObject = null;

	public Object getValueObject() {
		return this.valueObject;
	}

	public void setValueObject(Object valueObject) {
		this.valueObject = valueObject;
	}
	
	private final static String defaultCharset = java.nio.charset.Charset.defaultCharset().name();

	
	private final static String utf8Charset = "UTF-8";
	//contains type for every context property
	public class PropertiesWithType extends java.util.Properties {
		private static final long serialVersionUID = 1L;
		private java.util.Map<String,String> propertyTypes = new java.util.HashMap<>();
		
		public PropertiesWithType(java.util.Properties properties){
			super(properties);
		}
		public PropertiesWithType(){
			super();
		}
		
		public void setContextType(String key, String type) {
			propertyTypes.put(key,type);
		}
	
		public String getContextType(String key) {
			return propertyTypes.get(key);
		}
	}
	
	// create and load default properties
	private java.util.Properties defaultProps = new java.util.Properties();
	// create application properties with default
	public class ContextProperties extends PropertiesWithType {

		private static final long serialVersionUID = 1L;

		public ContextProperties(java.util.Properties properties){
			super(properties);
		}
		public ContextProperties(){
			super();
		}

		public void synchronizeContext(){
			
			if(main_path != null){
				
					this.setProperty("main_path", main_path.toString());
				
			}
			
			if(path_bulk != null){
				
					this.setProperty("path_bulk", path_bulk.toString());
				
			}
			
			if(path_original != null){
				
					this.setProperty("path_original", path_original.toString());
				
			}
			
			if(path_splitted != null){
				
					this.setProperty("path_splitted", path_splitted.toString());
				
			}
			
			if(regex_file_to_read != null){
				
					this.setProperty("regex_file_to_read", regex_file_to_read.toString());
				
			}
			
			if(sensors_path_input != null){
				
					this.setProperty("sensors_path_input", sensors_path_input.toString());
				
			}
			
			if(sensors_path_input_splitted != null){
				
					this.setProperty("sensors_path_input_splitted", sensors_path_input_splitted.toString());
				
			}
			
			if(sensors_path_output != null){
				
					this.setProperty("sensors_path_output", sensors_path_output.toString());
				
			}
			
			if(weather_path_input != null){
				
					this.setProperty("weather_path_input", weather_path_input.toString());
				
			}
			
			if(weather_path_input_splitted != null){
				
					this.setProperty("weather_path_input_splitted", weather_path_input_splitted.toString());
				
			}
			
			if(weather_path_output != null){
				
					this.setProperty("weather_path_output", weather_path_output.toString());
				
			}
			
			if(postgresWoneli_AdditionalParams != null){
				
					this.setProperty("postgresWoneli_AdditionalParams", postgresWoneli_AdditionalParams.toString());
				
			}
			
			if(postgresWoneli_Database != null){
				
					this.setProperty("postgresWoneli_Database", postgresWoneli_Database.toString());
				
			}
			
			if(postgresWoneli_Login != null){
				
					this.setProperty("postgresWoneli_Login", postgresWoneli_Login.toString());
				
			}
			
			if(postgresWoneli_Password != null){
				
					this.setProperty("postgresWoneli_Password", postgresWoneli_Password.toString());
				
			}
			
			if(postgresWoneli_Port != null){
				
					this.setProperty("postgresWoneli_Port", postgresWoneli_Port.toString());
				
			}
			
			if(postgresWoneli_Schema != null){
				
					this.setProperty("postgresWoneli_Schema", postgresWoneli_Schema.toString());
				
			}
			
			if(postgresWoneli_Server != null){
				
					this.setProperty("postgresWoneli_Server", postgresWoneli_Server.toString());
				
			}
			
			if(endpoinAPI_sensors_currentY != null){
				
					this.setProperty("endpoinAPI_sensors_currentY", endpoinAPI_sensors_currentY.toString());
				
			}
			
			if(endpoinAPI_stations_sensors != null){
				
					this.setProperty("endpoinAPI_stations_sensors", endpoinAPI_stations_sensors.toString());
				
			}
			
			if(endpoinAPI_stations_weather != null){
				
					this.setProperty("endpoinAPI_stations_weather", endpoinAPI_stations_weather.toString());
				
			}
			
			if(endpoinAPI_weather_currentM != null){
				
					this.setProperty("endpoinAPI_weather_currentM", endpoinAPI_weather_currentM.toString());
				
			}
			
			if(category != null){
				
					this.setProperty("category", category.toString());
				
			}
			
			if(csv_to_split != null){
				
					this.setProperty("csv_to_split", csv_to_split.toString());
				
			}
			
			if(duration != null){
				
					this.setProperty("duration", duration.toString());
				
			}
			
			if(num_rows != null){
				
					this.setProperty("num_rows", num_rows.toString());
				
			}
			
			if(operation != null){
				
					this.setProperty("operation", operation.toString());
				
			}
			
			if(table_name != null){
				
					this.setProperty("table_name", table_name.toString());
				
			}
			
			if(truncate != null){
				
					this.setProperty("truncate", truncate.toString());
				
			}
			
		}
		
		//if the stored or passed value is "<TALEND_NULL>" string, it mean null
		public String getStringValue(String key) {
			String origin_value = this.getProperty(key);
			if(NULL_VALUE_EXPRESSION_IN_COMMAND_STRING_FOR_CHILD_JOB_ONLY.equals(origin_value)) {
				return null;
			}
			return origin_value;
		}

		public String main_path;
		public String getMain_path(){
			return this.main_path;
		}
		
		public String path_bulk;
		public String getPath_bulk(){
			return this.path_bulk;
		}
		
		public String path_original;
		public String getPath_original(){
			return this.path_original;
		}
		
		public String path_splitted;
		public String getPath_splitted(){
			return this.path_splitted;
		}
		
public String regex_file_to_read;
public String getRegex_file_to_read(){
	return this.regex_file_to_read;
}
		public String sensors_path_input;
		public String getSensors_path_input(){
			return this.sensors_path_input;
		}
		
		public String sensors_path_input_splitted;
		public String getSensors_path_input_splitted(){
			return this.sensors_path_input_splitted;
		}
		
		public String sensors_path_output;
		public String getSensors_path_output(){
			return this.sensors_path_output;
		}
		
		public String weather_path_input;
		public String getWeather_path_input(){
			return this.weather_path_input;
		}
		
		public String weather_path_input_splitted;
		public String getWeather_path_input_splitted(){
			return this.weather_path_input_splitted;
		}
		
		public String weather_path_output;
		public String getWeather_path_output(){
			return this.weather_path_output;
		}
		
public String postgresWoneli_AdditionalParams;
public String getPostgresWoneli_AdditionalParams(){
	return this.postgresWoneli_AdditionalParams;
}
public String postgresWoneli_Database;
public String getPostgresWoneli_Database(){
	return this.postgresWoneli_Database;
}
public String postgresWoneli_Login;
public String getPostgresWoneli_Login(){
	return this.postgresWoneli_Login;
}
public java.lang.String postgresWoneli_Password;
public java.lang.String getPostgresWoneli_Password(){
	return this.postgresWoneli_Password;
}
public String postgresWoneli_Port;
public String getPostgresWoneli_Port(){
	return this.postgresWoneli_Port;
}
public String postgresWoneli_Schema;
public String getPostgresWoneli_Schema(){
	return this.postgresWoneli_Schema;
}
public String postgresWoneli_Server;
public String getPostgresWoneli_Server(){
	return this.postgresWoneli_Server;
}
public String endpoinAPI_sensors_currentY;
public String getEndpoinAPI_sensors_currentY(){
	return this.endpoinAPI_sensors_currentY;
}
public String endpoinAPI_stations_sensors;
public String getEndpoinAPI_stations_sensors(){
	return this.endpoinAPI_stations_sensors;
}
public String endpoinAPI_stations_weather;
public String getEndpoinAPI_stations_weather(){
	return this.endpoinAPI_stations_weather;
}
public String endpoinAPI_weather_currentM;
public String getEndpoinAPI_weather_currentM(){
	return this.endpoinAPI_weather_currentM;
}
public String category;
public String getCategory(){
	return this.category;
}
public String csv_to_split;
public String getCsv_to_split(){
	return this.csv_to_split;
}
public Integer duration;
public Integer getDuration(){
	return this.duration;
}
public Integer num_rows;
public Integer getNum_rows(){
	return this.num_rows;
}
public String operation;
public String getOperation(){
	return this.operation;
}
public String table_name;
public String getTable_name(){
	return this.table_name;
}
public Boolean truncate;
public Boolean getTruncate(){
	return this.truncate;
}
	}
	protected ContextProperties context = new ContextProperties(); // will be instanciated by MS.
	public ContextProperties getContext() {
		return this.context;
	}
	private final String jobVersion = "0.1";
	private final String jobName = "combineSplittedCsv";
	private final String projectName = "ARPA_DATA";
	public Integer errorCode = null;
	private String currentComponent = "";
	
		private final java.util.Map<String, Object> globalMap = new java.util.HashMap<String, Object>();
        private final static java.util.Map<String, Object> junitGlobalMap = new java.util.HashMap<String, Object>();
	
		private final java.util.Map<String, Long> start_Hash = new java.util.HashMap<String, Long>();
		private final java.util.Map<String, Long> end_Hash = new java.util.HashMap<String, Long>();
		private final java.util.Map<String, Boolean> ok_Hash = new java.util.HashMap<String, Boolean>();
		public  final java.util.List<String[]> globalBuffer = new java.util.ArrayList<String[]>();
	

private RunStat runStat = new RunStat();

	// OSGi DataSource
	private final static String KEY_DB_DATASOURCES = "KEY_DB_DATASOURCES";
	
	private final static String KEY_DB_DATASOURCES_RAW = "KEY_DB_DATASOURCES_RAW";

	public void setDataSources(java.util.Map<String, javax.sql.DataSource> dataSources) {
		java.util.Map<String, routines.system.TalendDataSource> talendDataSources = new java.util.HashMap<String, routines.system.TalendDataSource>();
		for (java.util.Map.Entry<String, javax.sql.DataSource> dataSourceEntry : dataSources.entrySet()) {
			talendDataSources.put(dataSourceEntry.getKey(), new routines.system.TalendDataSource(dataSourceEntry.getValue()));
		}
		globalMap.put(KEY_DB_DATASOURCES, talendDataSources);
		globalMap.put(KEY_DB_DATASOURCES_RAW, new java.util.HashMap<String, javax.sql.DataSource>(dataSources));
	}
	
	public void setDataSourceReferences(List serviceReferences) throws Exception{
		
		java.util.Map<String, routines.system.TalendDataSource> talendDataSources = new java.util.HashMap<String, routines.system.TalendDataSource>();
		java.util.Map<String, javax.sql.DataSource> dataSources = new java.util.HashMap<String, javax.sql.DataSource>();
		
		for (java.util.Map.Entry<String, javax.sql.DataSource> entry : BundleUtils.getServices(serviceReferences,  javax.sql.DataSource.class).entrySet()) {
                    dataSources.put(entry.getKey(), entry.getValue());
                    talendDataSources.put(entry.getKey(), new routines.system.TalendDataSource(entry.getValue()));
		}

		globalMap.put(KEY_DB_DATASOURCES, talendDataSources);
		globalMap.put(KEY_DB_DATASOURCES_RAW, new java.util.HashMap<String, javax.sql.DataSource>(dataSources));
	}


private final java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream();
private final java.io.PrintStream errorMessagePS = new java.io.PrintStream(new java.io.BufferedOutputStream(baos));

public String getExceptionStackTrace() {
	if ("failure".equals(this.getStatus())) {
		errorMessagePS.flush();
		return baos.toString();
	}
	return null;
}

private Exception exception;

public Exception getException() {
	if ("failure".equals(this.getStatus())) {
		return this.exception;
	}
	return null;
}

private class TalendException extends Exception {

	private static final long serialVersionUID = 1L;

	private java.util.Map<String, Object> globalMap = null;
	private Exception e = null;
	private String currentComponent = null;
	private String virtualComponentName = null;
	
	public void setVirtualComponentName (String virtualComponentName){
		this.virtualComponentName = virtualComponentName;
	}

	private TalendException(Exception e, String errorComponent, final java.util.Map<String, Object> globalMap) {
		this.currentComponent= errorComponent;
		this.globalMap = globalMap;
		this.e = e;
	}

	public Exception getException() {
		return this.e;
	}

	public String getCurrentComponent() {
		return this.currentComponent;
	}

	
    public String getExceptionCauseMessage(Exception e){
        Throwable cause = e;
        String message = null;
        int i = 10;
        while (null != cause && 0 < i--) {
            message = cause.getMessage();
            if (null == message) {
                cause = cause.getCause();
            } else {
                break;          
            }
        }
        if (null == message) {
            message = e.getClass().getName();
        }   
        return message;
    }

	@Override
	public void printStackTrace() {
		if (!(e instanceof TalendException || e instanceof TDieException)) {
			if(virtualComponentName!=null && currentComponent.indexOf(virtualComponentName+"_")==0){
				globalMap.put(virtualComponentName+"_ERROR_MESSAGE",getExceptionCauseMessage(e));
			}
			globalMap.put(currentComponent+"_ERROR_MESSAGE",getExceptionCauseMessage(e));
			System.err.println("Exception in component " + currentComponent + " (" + jobName + ")");
		}
		if (!(e instanceof TDieException)) {
			if(e instanceof TalendException){
				e.printStackTrace();
			} else {
				e.printStackTrace();
				e.printStackTrace(errorMessagePS);
				combineSplittedCsv.this.exception = e;
			}
		}
		if (!(e instanceof TalendException)) {
		try {
			for (java.lang.reflect.Method m : this.getClass().getEnclosingClass().getMethods()) {
				if (m.getName().compareTo(currentComponent + "_error") == 0) {
					m.invoke(combineSplittedCsv.this, new Object[] { e , currentComponent, globalMap});
					break;
				}
			}

			if(!(e instanceof TDieException)){
			}
		} catch (Exception e) {
			this.e.printStackTrace();
		}
		}
	}
}

			public void tFileList_1_error(Exception exception, String errorComponent, final java.util.Map<String, Object> globalMap) throws TalendException {
				
				end_Hash.put(errorComponent, System.currentTimeMillis());
				
				status = "failure";
				
					tFileList_1_onSubJobError(exception, errorComponent, globalMap);
			}
			
			public void tFileInputDelimited_1_error(Exception exception, String errorComponent, final java.util.Map<String, Object> globalMap) throws TalendException {
				
				end_Hash.put(errorComponent, System.currentTimeMillis());
				
				status = "failure";
				
					tFileList_1_onSubJobError(exception, errorComponent, globalMap);
			}
			
			public void tFileOutputDelimited_1_error(Exception exception, String errorComponent, final java.util.Map<String, Object> globalMap) throws TalendException {
				
				end_Hash.put(errorComponent, System.currentTimeMillis());
				
				status = "failure";
				
					tFileList_1_onSubJobError(exception, errorComponent, globalMap);
			}
			
			public void tFileDelete_1_error(Exception exception, String errorComponent, final java.util.Map<String, Object> globalMap) throws TalendException {
				
				end_Hash.put(errorComponent, System.currentTimeMillis());
				
				status = "failure";
				
					tFileDelete_1_onSubJobError(exception, errorComponent, globalMap);
			}
			
			public void tFileList_1_onSubJobError(Exception exception, String errorComponent, final java.util.Map<String, Object> globalMap) throws TalendException {

resumeUtil.addLog("SYSTEM_LOG", "NODE:"+ errorComponent, "", Thread.currentThread().getId()+ "", "FATAL", "", exception.getMessage(), ResumeUtil.getExceptionStackTrace(exception),"");

			}
			public void tFileDelete_1_onSubJobError(Exception exception, String errorComponent, final java.util.Map<String, Object> globalMap) throws TalendException {

resumeUtil.addLog("SYSTEM_LOG", "NODE:"+ errorComponent, "", Thread.currentThread().getId()+ "", "FATAL", "", exception.getMessage(), ResumeUtil.getExceptionStackTrace(exception),"");

			}
	






public static class appendStruct implements routines.system.IPersistableRow<appendStruct> {
    final static byte[] commonByteArrayLock_ARPA_DATA_combineSplittedCsv = new byte[0];
    static byte[] commonByteArray_ARPA_DATA_combineSplittedCsv = new byte[0];

	
			    public String idsensore;

				public String getIdsensore () {
					return this.idsensore;
				}
				
			    public String dataora;

				public String getDataora () {
					return this.dataora;
				}
				
			    public String valore;

				public String getValore () {
					return this.valore;
				}
				
			    public String stato;

				public String getStato () {
					return this.stato;
				}
				
			    public String idoperatore;

				public String getIdoperatore () {
					return this.idoperatore;
				}
				



	private String readString(ObjectInputStream dis) throws IOException{
		String strReturn = null;
		int length = 0;
        length = dis.readInt();
		if (length == -1) {
			strReturn = null;
		} else {
			if(length > commonByteArray_ARPA_DATA_combineSplittedCsv.length) {
				if(length < 1024 && commonByteArray_ARPA_DATA_combineSplittedCsv.length == 0) {
   					commonByteArray_ARPA_DATA_combineSplittedCsv = new byte[1024];
				} else {
   					commonByteArray_ARPA_DATA_combineSplittedCsv = new byte[2 * length];
   				}
			}
			dis.readFully(commonByteArray_ARPA_DATA_combineSplittedCsv, 0, length);
			strReturn = new String(commonByteArray_ARPA_DATA_combineSplittedCsv, 0, length, utf8Charset);
		}
		return strReturn;
	}
	
	private String readString(org.jboss.marshalling.Unmarshaller unmarshaller) throws IOException{
		String strReturn = null;
		int length = 0;
        length = unmarshaller.readInt();
		if (length == -1) {
			strReturn = null;
		} else {
			if(length > commonByteArray_ARPA_DATA_combineSplittedCsv.length) {
				if(length < 1024 && commonByteArray_ARPA_DATA_combineSplittedCsv.length == 0) {
   					commonByteArray_ARPA_DATA_combineSplittedCsv = new byte[1024];
				} else {
   					commonByteArray_ARPA_DATA_combineSplittedCsv = new byte[2 * length];
   				}
			}
			unmarshaller.readFully(commonByteArray_ARPA_DATA_combineSplittedCsv, 0, length);
			strReturn = new String(commonByteArray_ARPA_DATA_combineSplittedCsv, 0, length, utf8Charset);
		}
		return strReturn;
	}

    private void writeString(String str, ObjectOutputStream dos) throws IOException{
		if(str == null) {
            dos.writeInt(-1);
		} else {
            byte[] byteArray = str.getBytes(utf8Charset);
	    	dos.writeInt(byteArray.length);
			dos.write(byteArray);
    	}
    }
    
    private void writeString(String str, org.jboss.marshalling.Marshaller marshaller) throws IOException{
		if(str == null) {
			marshaller.writeInt(-1);
		} else {
            byte[] byteArray = str.getBytes(utf8Charset);
            marshaller.writeInt(byteArray.length);
            marshaller.write(byteArray);
    	}
    }

    public void readData(ObjectInputStream dis) {

		synchronized(commonByteArrayLock_ARPA_DATA_combineSplittedCsv) {

        	try {

        		int length = 0;
		
					this.idsensore = readString(dis);
					
					this.dataora = readString(dis);
					
					this.valore = readString(dis);
					
					this.stato = readString(dis);
					
					this.idoperatore = readString(dis);
					
        	} catch (IOException e) {
	            throw new RuntimeException(e);

		

        }

		

      }


    }
    
    public void readData(org.jboss.marshalling.Unmarshaller dis) {

		synchronized(commonByteArrayLock_ARPA_DATA_combineSplittedCsv) {

        	try {

        		int length = 0;
		
					this.idsensore = readString(dis);
					
					this.dataora = readString(dis);
					
					this.valore = readString(dis);
					
					this.stato = readString(dis);
					
					this.idoperatore = readString(dis);
					
        	} catch (IOException e) {
	            throw new RuntimeException(e);

		

        }

		

      }


    }

    public void writeData(ObjectOutputStream dos) {
        try {

		
					// String
				
						writeString(this.idsensore,dos);
					
					// String
				
						writeString(this.dataora,dos);
					
					// String
				
						writeString(this.valore,dos);
					
					// String
				
						writeString(this.stato,dos);
					
					// String
				
						writeString(this.idoperatore,dos);
					
        	} catch (IOException e) {
	            throw new RuntimeException(e);
        }


    }
    
    public void writeData(org.jboss.marshalling.Marshaller dos) {
        try {

		
					// String
				
						writeString(this.idsensore,dos);
					
					// String
				
						writeString(this.dataora,dos);
					
					// String
				
						writeString(this.valore,dos);
					
					// String
				
						writeString(this.stato,dos);
					
					// String
				
						writeString(this.idoperatore,dos);
					
        	} catch (IOException e) {
	            throw new RuntimeException(e);
        }


    }


    public String toString() {

		StringBuilder sb = new StringBuilder();
		sb.append(super.toString());
		sb.append("[");
		sb.append("idsensore="+idsensore);
		sb.append(",dataora="+dataora);
		sb.append(",valore="+valore);
		sb.append(",stato="+stato);
		sb.append(",idoperatore="+idoperatore);
	    sb.append("]");

	    return sb.toString();
    }

    /**
     * Compare keys
     */
    public int compareTo(appendStruct other) {

		int returnValue = -1;
		
	    return returnValue;
    }


    private int checkNullsAndCompare(Object object1, Object object2) {
        int returnValue = 0;
		if (object1 instanceof Comparable && object2 instanceof Comparable) {
            returnValue = ((Comparable) object1).compareTo(object2);
        } else if (object1 != null && object2 != null) {
            returnValue = compareStrings(object1.toString(), object2.toString());
        } else if (object1 == null && object2 != null) {
            returnValue = 1;
        } else if (object1 != null && object2 == null) {
            returnValue = -1;
        } else {
            returnValue = 0;
        }

        return returnValue;
    }

    private int compareStrings(String string1, String string2) {
        return string1.compareTo(string2);
    }


}
public void tFileList_1Process(final java.util.Map<String, Object> globalMap) throws TalendException {
	globalMap.put("tFileList_1_SUBPROCESS_STATE", 0);

 final boolean execStat = this.execStat;
	
		String iterateId = "";
	
	
	String currentComponent = "";
	java.util.Map<String, Object> resourceMap = new java.util.HashMap<String, Object>();

	try {
			// TDI-39566 avoid throwing an useless Exception
			boolean resumeIt = true;
			if (globalResumeTicket == false && resumeEntryMethodName != null) {
				String currentMethodName = new java.lang.Exception().getStackTrace()[0].getMethodName();
				resumeIt = resumeEntryMethodName.equals(currentMethodName);
			}
			if (resumeIt || globalResumeTicket) { //start the resume
				globalResumeTicket = true;



		appendStruct append = new appendStruct();



	
	/**
	 * [tFileList_1 begin ] start
	 */

				
			int NB_ITERATE_tFileInputDelimited_1 = 0; //for statistics
			

	
		
		ok_Hash.put("tFileList_1", false);
		start_Hash.put("tFileList_1", System.currentTimeMillis());
		
	
	currentComponent="tFileList_1";

	
		int tos_count_tFileList_1 = 0;
		
	
 
     
    
  String directory_tFileList_1 = context.path_bulk;
  final java.util.List<String> maskList_tFileList_1 = new java.util.ArrayList<String>();
  final java.util.List<java.util.regex.Pattern> patternList_tFileList_1 = new java.util.ArrayList<java.util.regex.Pattern>(); 
    maskList_tFileList_1.add("mod_int.*[0-9]+.csv");  
  for (final String filemask_tFileList_1 : maskList_tFileList_1) {
	String filemask_compile_tFileList_1 = filemask_tFileList_1;
	
		java.util.regex.Pattern fileNamePattern_tFileList_1 = java.util.regex.Pattern.compile(filemask_compile_tFileList_1);
	patternList_tFileList_1.add(fileNamePattern_tFileList_1);
  }
  int NB_FILEtFileList_1 = 0;

  final boolean case_sensitive_tFileList_1 = true;
	
	
	
    final java.util.List<java.io.File> list_tFileList_1 = new java.util.ArrayList<java.io.File>();
    final java.util.Set<String> filePath_tFileList_1 = new java.util.HashSet<String>();
	java.io.File file_tFileList_1 = new java.io.File(directory_tFileList_1);
     
		file_tFileList_1.listFiles(new java.io.FilenameFilter() {
			public boolean accept(java.io.File dir, String name) {
				java.io.File file = new java.io.File(dir, name);
                if (!file.isDirectory()) {
                	
    	String fileName_tFileList_1 = file.getName();
		for (final java.util.regex.Pattern fileNamePattern_tFileList_1 : patternList_tFileList_1) {
          	if (fileNamePattern_tFileList_1.matcher(fileName_tFileList_1).matches()){
					if(!filePath_tFileList_1.contains(file.getAbsolutePath())) {
			          list_tFileList_1.add(file);
			          filePath_tFileList_1.add(file.getAbsolutePath());
			        }
			}
		}
                }
              return true;
            }
          }
      );   
        Comparator<java.io.File> fileNameASC_tFileList_1 = new Comparator<java.io.File>() {
        
          public int compare(java.io.File o1, java.io.File o2) {
            boolean bO1IsFile = o1.isFile();
            boolean bO2IsFile = o2.isFile();
            
            if (bO1IsFile && bO2IsFile) {
                return (o1.getName()).compareTo(o2.getName());
            } else if (bO1IsFile && (!bO2IsFile)) {
                return 1;
            } else if ((!bO1IsFile) && bO2IsFile) {
                return -1;
            } else if (!bO1IsFile && !bO2IsFile) {
                return (o1.getName()).compareTo(o2.getName());
            } else {
                return 0;
            }
          }
        };
      java.util.Collections.sort(list_tFileList_1, fileNameASC_tFileList_1);
    
    for (int i_tFileList_1 = 0; i_tFileList_1 < list_tFileList_1.size(); i_tFileList_1++){
      java.io.File files_tFileList_1 = list_tFileList_1.get(i_tFileList_1);
      String fileName_tFileList_1 = files_tFileList_1.getName();
      
      String currentFileName_tFileList_1 = files_tFileList_1.getName(); 
      String currentFilePath_tFileList_1 = files_tFileList_1.getAbsolutePath();
      String currentFileDirectory_tFileList_1 = files_tFileList_1.getParent();
      String currentFileExtension_tFileList_1 = null;
      
      if (files_tFileList_1.getName().contains(".") && files_tFileList_1.isFile()){
        currentFileExtension_tFileList_1 = files_tFileList_1.getName().substring(files_tFileList_1.getName().lastIndexOf(".") + 1);
      } else{
        currentFileExtension_tFileList_1 = "";
      }
      
      NB_FILEtFileList_1 ++;
      globalMap.put("tFileList_1_CURRENT_FILE", currentFileName_tFileList_1);
      globalMap.put("tFileList_1_CURRENT_FILEPATH", currentFilePath_tFileList_1);
      globalMap.put("tFileList_1_CURRENT_FILEDIRECTORY", currentFileDirectory_tFileList_1);
      globalMap.put("tFileList_1_CURRENT_FILEEXTENSION", currentFileExtension_tFileList_1);
      globalMap.put("tFileList_1_NB_FILE", NB_FILEtFileList_1);
      
 



/**
 * [tFileList_1 begin ] stop
 */
	
	/**
	 * [tFileList_1 main ] start
	 */

	

	
	
	currentComponent="tFileList_1";

	

 


	tos_count_tFileList_1++;

/**
 * [tFileList_1 main ] stop
 */
	
	/**
	 * [tFileList_1 process_data_begin ] start
	 */

	

	
	
	currentComponent="tFileList_1";

	

 



/**
 * [tFileList_1 process_data_begin ] stop
 */
	NB_ITERATE_tFileInputDelimited_1++;
	
	
					if(execStat){				
	       				runStat.updateStatOnConnection("append", 3, 0);
					}           			
				
					if(execStat){				
	       				runStat.updateStatOnConnection("OnComponentOk1", 3, 0);
					}           			
				
				if(execStat){
					runStat.updateStatOnConnection("iterate1", 1, "exec" + NB_ITERATE_tFileInputDelimited_1);
					//Thread.sleep(1000);
				}				
			


	
	/**
	 * [tFileOutputDelimited_1 begin ] start
	 */

	

	
		
		ok_Hash.put("tFileOutputDelimited_1", false);
		start_Hash.put("tFileOutputDelimited_1", System.currentTimeMillis());
		
	
	currentComponent="tFileOutputDelimited_1";

	
					if(execStat) {
						runStat.updateStatOnConnection(resourceMap,iterateId,0,0,"append");
					}
				
		int tos_count_tFileOutputDelimited_1 = 0;
		

String fileName_tFileOutputDelimited_1 = "";
    fileName_tFileOutputDelimited_1 = (new java.io.File(context.path_bulk + "mod_" + ((String)globalMap.get("tFileList_1_CURRENT_FILE")).substring(8))).getAbsolutePath().replace("\\","/");
    String fullName_tFileOutputDelimited_1 = null;
    String extension_tFileOutputDelimited_1 = null;
    String directory_tFileOutputDelimited_1 = null;
    if((fileName_tFileOutputDelimited_1.indexOf("/") != -1)) {
        if(fileName_tFileOutputDelimited_1.lastIndexOf(".") < fileName_tFileOutputDelimited_1.lastIndexOf("/")) {
            fullName_tFileOutputDelimited_1 = fileName_tFileOutputDelimited_1;
            extension_tFileOutputDelimited_1 = "";
        } else {
            fullName_tFileOutputDelimited_1 = fileName_tFileOutputDelimited_1.substring(0, fileName_tFileOutputDelimited_1.lastIndexOf("."));
            extension_tFileOutputDelimited_1 = fileName_tFileOutputDelimited_1.substring(fileName_tFileOutputDelimited_1.lastIndexOf("."));
        }
        directory_tFileOutputDelimited_1 = fileName_tFileOutputDelimited_1.substring(0, fileName_tFileOutputDelimited_1.lastIndexOf("/"));
    } else {
        if(fileName_tFileOutputDelimited_1.lastIndexOf(".") != -1) {
            fullName_tFileOutputDelimited_1 = fileName_tFileOutputDelimited_1.substring(0, fileName_tFileOutputDelimited_1.lastIndexOf("."));
            extension_tFileOutputDelimited_1 = fileName_tFileOutputDelimited_1.substring(fileName_tFileOutputDelimited_1.lastIndexOf("."));
        } else {
            fullName_tFileOutputDelimited_1 = fileName_tFileOutputDelimited_1;
            extension_tFileOutputDelimited_1 = "";
        }
        directory_tFileOutputDelimited_1 = "";
    }
    boolean isFileGenerated_tFileOutputDelimited_1 = true;
    java.io.File filetFileOutputDelimited_1 = new java.io.File(fileName_tFileOutputDelimited_1);
    globalMap.put("tFileOutputDelimited_1_FILE_NAME",fileName_tFileOutputDelimited_1);
        if(filetFileOutputDelimited_1.exists()){
            isFileGenerated_tFileOutputDelimited_1 = false;
        }
            int nb_line_tFileOutputDelimited_1 = 0;
            int splitedFileNo_tFileOutputDelimited_1 = 0;
            int currentRow_tFileOutputDelimited_1 = 0;

            final String OUT_DELIM_tFileOutputDelimited_1 = /** Start field tFileOutputDelimited_1:FIELDSEPARATOR */";"/** End field tFileOutputDelimited_1:FIELDSEPARATOR */;

            final String OUT_DELIM_ROWSEP_tFileOutputDelimited_1 = /** Start field tFileOutputDelimited_1:ROWSEPARATOR */"\n"/** End field tFileOutputDelimited_1:ROWSEPARATOR */;

                    //create directory only if not exists
                    if(directory_tFileOutputDelimited_1 != null && directory_tFileOutputDelimited_1.trim().length() != 0) {
                        java.io.File dir_tFileOutputDelimited_1 = new java.io.File(directory_tFileOutputDelimited_1);
                        if(!dir_tFileOutputDelimited_1.exists()) {
                            dir_tFileOutputDelimited_1.mkdirs();
                        }
                    }

                        //routines.system.Row
                        java.io.Writer outtFileOutputDelimited_1 = null;

                        outtFileOutputDelimited_1 = new java.io.BufferedWriter(new java.io.OutputStreamWriter(
                        new java.io.FileOutputStream(fileName_tFileOutputDelimited_1, true),"ISO-8859-15"));
                                    if(filetFileOutputDelimited_1.length()==0){
                                        outtFileOutputDelimited_1.write("idsensore");
                                            outtFileOutputDelimited_1.write(OUT_DELIM_tFileOutputDelimited_1);
                                        outtFileOutputDelimited_1.write("dataora");
                                            outtFileOutputDelimited_1.write(OUT_DELIM_tFileOutputDelimited_1);
                                        outtFileOutputDelimited_1.write("valore");
                                            outtFileOutputDelimited_1.write(OUT_DELIM_tFileOutputDelimited_1);
                                        outtFileOutputDelimited_1.write("stato");
                                            outtFileOutputDelimited_1.write(OUT_DELIM_tFileOutputDelimited_1);
                                        outtFileOutputDelimited_1.write("idoperatore");
                                        outtFileOutputDelimited_1.write(OUT_DELIM_ROWSEP_tFileOutputDelimited_1);
                                        outtFileOutputDelimited_1.flush();
                                    }


        resourceMap.put("out_tFileOutputDelimited_1", outtFileOutputDelimited_1);
resourceMap.put("nb_line_tFileOutputDelimited_1", nb_line_tFileOutputDelimited_1);

 



/**
 * [tFileOutputDelimited_1 begin ] stop
 */



	
	/**
	 * [tFileInputDelimited_1 begin ] start
	 */

	

	
		
		ok_Hash.put("tFileInputDelimited_1", false);
		start_Hash.put("tFileInputDelimited_1", System.currentTimeMillis());
		
	
	currentComponent="tFileInputDelimited_1";

	
		int tos_count_tFileInputDelimited_1 = 0;
		
	
	
	
 
	
	
	final routines.system.RowState rowstate_tFileInputDelimited_1 = new routines.system.RowState();
	
	
				int nb_line_tFileInputDelimited_1 = 0;
				org.talend.fileprocess.FileInputDelimited fid_tFileInputDelimited_1 = null;
				int limit_tFileInputDelimited_1 = -1;
				try{
					
						Object filename_tFileInputDelimited_1 = context.path_bulk+((String)globalMap.get("tFileList_1_CURRENT_FILE"));
						if(filename_tFileInputDelimited_1 instanceof java.io.InputStream){
							
			int footer_value_tFileInputDelimited_1 = 0, random_value_tFileInputDelimited_1 = -1;
			if(footer_value_tFileInputDelimited_1 >0 || random_value_tFileInputDelimited_1 > 0){
				throw new java.lang.Exception("When the input source is a stream,footer and random shouldn't be bigger than 0.");				
			}
		
						}
						try {
							fid_tFileInputDelimited_1 = new org.talend.fileprocess.FileInputDelimited(context.path_bulk+((String)globalMap.get("tFileList_1_CURRENT_FILE")), "ISO-8859-15",";","\n",true,1,0,
									limit_tFileInputDelimited_1
								,-1, false);
						} catch(java.lang.Exception e) {
globalMap.put("tFileInputDelimited_1_ERROR_MESSAGE",e.getMessage());
							
								throw e;
							
						}
					
				    
					while (fid_tFileInputDelimited_1!=null && fid_tFileInputDelimited_1.nextRecord()) {
						rowstate_tFileInputDelimited_1.reset();
						
			    						append = null;			
												
									boolean whetherReject_tFileInputDelimited_1 = false;
									append = new appendStruct();
									try {
										
				int columnIndexWithD_tFileInputDelimited_1 = 0;
				
					columnIndexWithD_tFileInputDelimited_1 = 0;
					
							append.idsensore = fid_tFileInputDelimited_1.get(columnIndexWithD_tFileInputDelimited_1);
						
				
					columnIndexWithD_tFileInputDelimited_1 = 1;
					
							append.dataora = fid_tFileInputDelimited_1.get(columnIndexWithD_tFileInputDelimited_1);
						
				
					columnIndexWithD_tFileInputDelimited_1 = 2;
					
							append.valore = fid_tFileInputDelimited_1.get(columnIndexWithD_tFileInputDelimited_1);
						
				
					columnIndexWithD_tFileInputDelimited_1 = 3;
					
							append.stato = fid_tFileInputDelimited_1.get(columnIndexWithD_tFileInputDelimited_1);
						
				
					columnIndexWithD_tFileInputDelimited_1 = 4;
					
							append.idoperatore = fid_tFileInputDelimited_1.get(columnIndexWithD_tFileInputDelimited_1);
						
				
				
										
										if(rowstate_tFileInputDelimited_1.getException()!=null) {
											throw rowstate_tFileInputDelimited_1.getException();
										}
										
										
							
			    					} catch (java.lang.Exception e) {
globalMap.put("tFileInputDelimited_1_ERROR_MESSAGE",e.getMessage());
			        					whetherReject_tFileInputDelimited_1 = true;
			        					
			            					throw(e);
			            				
			    					}
								

 



/**
 * [tFileInputDelimited_1 begin ] stop
 */
	
	/**
	 * [tFileInputDelimited_1 main ] start
	 */

	

	
	
	currentComponent="tFileInputDelimited_1";

	

 


	tos_count_tFileInputDelimited_1++;

/**
 * [tFileInputDelimited_1 main ] stop
 */
	
	/**
	 * [tFileInputDelimited_1 process_data_begin ] start
	 */

	

	
	
	currentComponent="tFileInputDelimited_1";

	

 



/**
 * [tFileInputDelimited_1 process_data_begin ] stop
 */
// Start of branch "append"
if(append != null) { 



	
	/**
	 * [tFileOutputDelimited_1 main ] start
	 */

	

	
	
	currentComponent="tFileOutputDelimited_1";

	
					if(execStat){
						runStat.updateStatOnConnection(iterateId,1,1
						
							,"append"
						
						);
					}
					


                    StringBuilder sb_tFileOutputDelimited_1 = new StringBuilder();
                            if(append.idsensore != null) {
                        sb_tFileOutputDelimited_1.append(
                            append.idsensore
                        );
                            }
                            sb_tFileOutputDelimited_1.append(OUT_DELIM_tFileOutputDelimited_1);
                            if(append.dataora != null) {
                        sb_tFileOutputDelimited_1.append(
                            append.dataora
                        );
                            }
                            sb_tFileOutputDelimited_1.append(OUT_DELIM_tFileOutputDelimited_1);
                            if(append.valore != null) {
                        sb_tFileOutputDelimited_1.append(
                            append.valore
                        );
                            }
                            sb_tFileOutputDelimited_1.append(OUT_DELIM_tFileOutputDelimited_1);
                            if(append.stato != null) {
                        sb_tFileOutputDelimited_1.append(
                            append.stato
                        );
                            }
                            sb_tFileOutputDelimited_1.append(OUT_DELIM_tFileOutputDelimited_1);
                            if(append.idoperatore != null) {
                        sb_tFileOutputDelimited_1.append(
                            append.idoperatore
                        );
                            }
                    sb_tFileOutputDelimited_1.append(OUT_DELIM_ROWSEP_tFileOutputDelimited_1);


                    nb_line_tFileOutputDelimited_1++;
                    resourceMap.put("nb_line_tFileOutputDelimited_1", nb_line_tFileOutputDelimited_1);

                        outtFileOutputDelimited_1.write(sb_tFileOutputDelimited_1.toString());




 


	tos_count_tFileOutputDelimited_1++;

/**
 * [tFileOutputDelimited_1 main ] stop
 */
	
	/**
	 * [tFileOutputDelimited_1 process_data_begin ] start
	 */

	

	
	
	currentComponent="tFileOutputDelimited_1";

	

 



/**
 * [tFileOutputDelimited_1 process_data_begin ] stop
 */
	
	/**
	 * [tFileOutputDelimited_1 process_data_end ] start
	 */

	

	
	
	currentComponent="tFileOutputDelimited_1";

	

 



/**
 * [tFileOutputDelimited_1 process_data_end ] stop
 */

} // End of branch "append"




	
	/**
	 * [tFileInputDelimited_1 process_data_end ] start
	 */

	

	
	
	currentComponent="tFileInputDelimited_1";

	

 



/**
 * [tFileInputDelimited_1 process_data_end ] stop
 */
	
	/**
	 * [tFileInputDelimited_1 end ] start
	 */

	

	
	
	currentComponent="tFileInputDelimited_1";

	



            }
            }finally{
                if(!((Object)(context.path_bulk+((String)globalMap.get("tFileList_1_CURRENT_FILE"))) instanceof java.io.InputStream)){
                	if(fid_tFileInputDelimited_1!=null){
                		fid_tFileInputDelimited_1.close();
                	}
                }
                if(fid_tFileInputDelimited_1!=null){
                	globalMap.put("tFileInputDelimited_1_NB_LINE", fid_tFileInputDelimited_1.getRowNumber());
					
                }
			}
			  

 

ok_Hash.put("tFileInputDelimited_1", true);
end_Hash.put("tFileInputDelimited_1", System.currentTimeMillis());




/**
 * [tFileInputDelimited_1 end ] stop
 */

	
	/**
	 * [tFileOutputDelimited_1 end ] start
	 */

	

	
	
	currentComponent="tFileOutputDelimited_1";

	



		
			
					if(outtFileOutputDelimited_1!=null) {
						outtFileOutputDelimited_1.flush();
						outtFileOutputDelimited_1.close();
					}
				
				globalMap.put("tFileOutputDelimited_1_NB_LINE",nb_line_tFileOutputDelimited_1);
				globalMap.put("tFileOutputDelimited_1_FILE_NAME",fileName_tFileOutputDelimited_1);
			
		
		
		resourceMap.put("finish_tFileOutputDelimited_1", true);
	

				if(execStat){
			  		runStat.updateStat(resourceMap,iterateId,2,0,"append");
			  	}
			  	
 

ok_Hash.put("tFileOutputDelimited_1", true);
end_Hash.put("tFileOutputDelimited_1", System.currentTimeMillis());

				if(execStat){   
   	 				runStat.updateStatOnConnection("OnComponentOk1", 0, "ok");
				}
				tFileDelete_1Process(globalMap);



/**
 * [tFileOutputDelimited_1 end ] stop
 */



						if(execStat){
							runStat.updateStatOnConnection("iterate1", 2, "exec" + NB_ITERATE_tFileInputDelimited_1);
						}				
					




	
	/**
	 * [tFileList_1 process_data_end ] start
	 */

	

	
	
	currentComponent="tFileList_1";

	

 



/**
 * [tFileList_1 process_data_end ] stop
 */
	
	/**
	 * [tFileList_1 end ] start
	 */

	

	
	
	currentComponent="tFileList_1";

	

  
    }
  globalMap.put("tFileList_1_NB_FILE", NB_FILEtFileList_1);
  

  
 

 

ok_Hash.put("tFileList_1", true);
end_Hash.put("tFileList_1", System.currentTimeMillis());




/**
 * [tFileList_1 end ] stop
 */
				}//end the resume

				



	
			}catch(java.lang.Exception e){	
				
				TalendException te = new TalendException(e, currentComponent, globalMap);
				
				throw te;
			}catch(java.lang.Error error){	
				
					runStat.stopThreadStat();
				
				throw error;
			}finally{
				
				try{
					
	
	/**
	 * [tFileList_1 finally ] start
	 */

	

	
	
	currentComponent="tFileList_1";

	

 



/**
 * [tFileList_1 finally ] stop
 */

	
	/**
	 * [tFileInputDelimited_1 finally ] start
	 */

	

	
	
	currentComponent="tFileInputDelimited_1";

	

 



/**
 * [tFileInputDelimited_1 finally ] stop
 */

	
	/**
	 * [tFileOutputDelimited_1 finally ] start
	 */

	

	
	
	currentComponent="tFileOutputDelimited_1";

	


		if(resourceMap.get("finish_tFileOutputDelimited_1") == null){ 
			
				
						java.io.Writer outtFileOutputDelimited_1 = (java.io.Writer)resourceMap.get("out_tFileOutputDelimited_1");
						if(outtFileOutputDelimited_1!=null) {
							outtFileOutputDelimited_1.flush();
							outtFileOutputDelimited_1.close();
						}
					
				
			
		}
	

 



/**
 * [tFileOutputDelimited_1 finally ] stop
 */






				}catch(java.lang.Exception e){	
					//ignore
				}catch(java.lang.Error error){
					//ignore
				}
				resourceMap = null;
			}
		

		globalMap.put("tFileList_1_SUBPROCESS_STATE", 1);
	}
	

public void tFileDelete_1Process(final java.util.Map<String, Object> globalMap) throws TalendException {
	globalMap.put("tFileDelete_1_SUBPROCESS_STATE", 0);

 final boolean execStat = this.execStat;
	
		String iterateId = "";
	
	
	String currentComponent = "";
	java.util.Map<String, Object> resourceMap = new java.util.HashMap<String, Object>();

	try {
			// TDI-39566 avoid throwing an useless Exception
			boolean resumeIt = true;
			if (globalResumeTicket == false && resumeEntryMethodName != null) {
				String currentMethodName = new java.lang.Exception().getStackTrace()[0].getMethodName();
				resumeIt = resumeEntryMethodName.equals(currentMethodName);
			}
			if (resumeIt || globalResumeTicket) { //start the resume
				globalResumeTicket = true;





	
	/**
	 * [tFileDelete_1 begin ] start
	 */

	

	
		
		ok_Hash.put("tFileDelete_1", false);
		start_Hash.put("tFileDelete_1", System.currentTimeMillis());
		
	
	currentComponent="tFileDelete_1";

	
		int tos_count_tFileDelete_1 = 0;
		

 



/**
 * [tFileDelete_1 begin ] stop
 */
	
	/**
	 * [tFileDelete_1 main ] start
	 */

	

	
	
	currentComponent="tFileDelete_1";

	

 

class DeleteFoldertFileDelete_1{
	 /**
     * delete all the sub-files in 'file'
     * 
     * @param file
     */
	public boolean delete(java.io.File file) {
        java.io.File[] files = file.listFiles();
        for (int i = 0; i < files.length; i++) {
            if (files[i].isFile()) {
                files[i].delete();
            } else if (files[i].isDirectory()) {
                if (!files[i].delete()) {
                    delete(files[i]);
                }
            }
        }
        deleteDirectory(file);
        return file.delete();
    }

    /**
     * delete all the sub-folders in 'file'
     * 
     * @param file
     */
    private void deleteDirectory(java.io.File file) {
        java.io.File[] filed = file.listFiles();
        for (int i = 0; i < filed.length; i++) {
        	if(filed[i].isDirectory()) {
            	deleteDirectory(filed[i]);
            }
            filed[i].delete();
        }
    }

}
    java.io.File file_tFileDelete_1=new java.io.File(context.path_bulk +((String)globalMap.get("tFileList_1_CURRENT_FILE")));
    if(file_tFileDelete_1.exists()&& file_tFileDelete_1.isFile()){
    	if(file_tFileDelete_1.delete()){
    		globalMap.put("tFileDelete_1_CURRENT_STATUS", "File deleted.");
		}else{
			globalMap.put("tFileDelete_1_CURRENT_STATUS", "No file deleted.");
				throw new RuntimeException("File " + file_tFileDelete_1.getAbsolutePath() + " can not be deleted.");
		}
	}else{
		globalMap.put("tFileDelete_1_CURRENT_STATUS", "File does not exist or is invalid.");
			throw new RuntimeException("File " + file_tFileDelete_1.getAbsolutePath() + " does not exist or is invalid or is not a file.");
	}
	globalMap.put("tFileDelete_1_DELETE_PATH",context.path_bulk +((String)globalMap.get("tFileList_1_CURRENT_FILE")));
 


	tos_count_tFileDelete_1++;

/**
 * [tFileDelete_1 main ] stop
 */
	
	/**
	 * [tFileDelete_1 process_data_begin ] start
	 */

	

	
	
	currentComponent="tFileDelete_1";

	

 



/**
 * [tFileDelete_1 process_data_begin ] stop
 */
	
	/**
	 * [tFileDelete_1 process_data_end ] start
	 */

	

	
	
	currentComponent="tFileDelete_1";

	

 



/**
 * [tFileDelete_1 process_data_end ] stop
 */
	
	/**
	 * [tFileDelete_1 end ] start
	 */

	

	
	
	currentComponent="tFileDelete_1";

	

 

ok_Hash.put("tFileDelete_1", true);
end_Hash.put("tFileDelete_1", System.currentTimeMillis());




/**
 * [tFileDelete_1 end ] stop
 */
				}//end the resume

				



	
			}catch(java.lang.Exception e){	
				
				TalendException te = new TalendException(e, currentComponent, globalMap);
				
				throw te;
			}catch(java.lang.Error error){	
				
					runStat.stopThreadStat();
				
				throw error;
			}finally{
				
				try{
					
	
	/**
	 * [tFileDelete_1 finally ] start
	 */

	

	
	
	currentComponent="tFileDelete_1";

	

 



/**
 * [tFileDelete_1 finally ] stop
 */
				}catch(java.lang.Exception e){	
					//ignore
				}catch(java.lang.Error error){
					//ignore
				}
				resourceMap = null;
			}
		

		globalMap.put("tFileDelete_1_SUBPROCESS_STATE", 1);
	}
	
    public String resuming_logs_dir_path = null;
    public String resuming_checkpoint_path = null;
    public String parent_part_launcher = null;
    private String resumeEntryMethodName = null;
    private boolean globalResumeTicket = false;

    public boolean watch = false;
    // portStats is null, it means don't execute the statistics
    public Integer portStats = null;
    public int portTraces = 4334;
    public String clientHost;
    public String defaultClientHost = "localhost";
    public String contextStr = "Default";
    public boolean isDefaultContext = true;
    public String pid = "0";
    public String rootPid = null;
    public String fatherPid = null;
    public String fatherNode = null;
    public long startTime = 0;
    public boolean isChildJob = false;
    public String log4jLevel = "";
    
    private boolean enableLogStash;

    private boolean execStat = true;

    private ThreadLocal<java.util.Map<String, String>> threadLocal = new ThreadLocal<java.util.Map<String, String>>() {
        protected java.util.Map<String, String> initialValue() {
            java.util.Map<String,String> threadRunResultMap = new java.util.HashMap<String, String>();
            threadRunResultMap.put("errorCode", null);
            threadRunResultMap.put("status", "");
            return threadRunResultMap;
        };
    };


    protected PropertiesWithType context_param = new PropertiesWithType();
    public java.util.Map<String, Object> parentContextMap = new java.util.HashMap<String, Object>();

    public String status= "";
    

    public static void main(String[] args){
        final combineSplittedCsv combineSplittedCsvClass = new combineSplittedCsv();

        int exitCode = combineSplittedCsvClass.runJobInTOS(args);

        System.exit(exitCode);
    }


    public String[][] runJob(String[] args) {

        int exitCode = runJobInTOS(args);
        String[][] bufferValue = new String[][] { { Integer.toString(exitCode) } };

        return bufferValue;
    }

    public boolean hastBufferOutputComponent() {
		boolean hastBufferOutput = false;
    	
        return hastBufferOutput;
    }

    public int runJobInTOS(String[] args) {
	   	// reset status
	   	status = "";
	   	
        String lastStr = "";
        for (String arg : args) {
            if (arg.equalsIgnoreCase("--context_param")) {
                lastStr = arg;
            } else if (lastStr.equals("")) {
                evalParam(arg);
            } else {
                evalParam(lastStr + " " + arg);
                lastStr = "";
            }
        }
        enableLogStash = "true".equalsIgnoreCase(System.getProperty("audit.enabled"));

    	
    	

        if(clientHost == null) {
            clientHost = defaultClientHost;
        }

        if(pid == null || "0".equals(pid)) {
            pid = TalendString.getAsciiRandomString(6);
        }

        if (rootPid==null) {
            rootPid = pid;
        }
        if (fatherPid==null) {
            fatherPid = pid;
        }else{
            isChildJob = true;
        }

        if (portStats != null) {
            // portStats = -1; //for testing
            if (portStats < 0 || portStats > 65535) {
                // issue:10869, the portStats is invalid, so this client socket can't open
                System.err.println("The statistics socket port " + portStats + " is invalid.");
                execStat = false;
            }
        } else {
            execStat = false;
        }
        boolean inOSGi = routines.system.BundleUtils.inOSGi();

        if (inOSGi) {
            java.util.Dictionary<String, Object> jobProperties = routines.system.BundleUtils.getJobProperties(jobName);

            if (jobProperties != null && jobProperties.get("context") != null) {
                contextStr = (String)jobProperties.get("context");
            }
        }

        try {
            //call job/subjob with an existing context, like: --context=production. if without this parameter, there will use the default context instead.
            java.io.InputStream inContext = combineSplittedCsv.class.getClassLoader().getResourceAsStream("arpa_data/combinesplittedcsv_0_1/contexts/" + contextStr + ".properties");
            if (inContext == null) {
                inContext = combineSplittedCsv.class.getClassLoader().getResourceAsStream("config/contexts/" + contextStr + ".properties");
            }
            if (inContext != null) {
                try {
                    //defaultProps is in order to keep the original context value
                    if(context != null && context.isEmpty()) {
	                defaultProps.load(inContext);
	                context = new ContextProperties(defaultProps);
                    }
                } finally {
                    inContext.close();
                }
            } else if (!isDefaultContext) {
                //print info and job continue to run, for case: context_param is not empty.
                System.err.println("Could not find the context " + contextStr);
            }

            if(!context_param.isEmpty()) {
                context.putAll(context_param);
				//set types for params from parentJobs
				for (Object key: context_param.keySet()){
					String context_key = key.toString();
					String context_type = context_param.getContextType(context_key);
					context.setContextType(context_key, context_type);

				}
            }
            class ContextProcessing {
                private void processContext_0() {
                        context.setContextType("main_path", "id_Directory");
                        if(context.getStringValue("main_path") == null) {
                            context.main_path = null;
                        } else {
                            context.main_path=(String) context.getProperty("main_path");
                        }
                        context.setContextType("path_bulk", "id_Directory");
                        if(context.getStringValue("path_bulk") == null) {
                            context.path_bulk = null;
                        } else {
                            context.path_bulk=(String) context.getProperty("path_bulk");
                        }
                        context.setContextType("path_original", "id_Directory");
                        if(context.getStringValue("path_original") == null) {
                            context.path_original = null;
                        } else {
                            context.path_original=(String) context.getProperty("path_original");
                        }
                        context.setContextType("path_splitted", "id_Directory");
                        if(context.getStringValue("path_splitted") == null) {
                            context.path_splitted = null;
                        } else {
                            context.path_splitted=(String) context.getProperty("path_splitted");
                        }
                        context.setContextType("regex_file_to_read", "id_String");
                        if(context.getStringValue("regex_file_to_read") == null) {
                            context.regex_file_to_read = null;
                        } else {
                            context.regex_file_to_read=(String) context.getProperty("regex_file_to_read");
                        }
                        context.setContextType("sensors_path_input", "id_Directory");
                        if(context.getStringValue("sensors_path_input") == null) {
                            context.sensors_path_input = null;
                        } else {
                            context.sensors_path_input=(String) context.getProperty("sensors_path_input");
                        }
                        context.setContextType("sensors_path_input_splitted", "id_Directory");
                        if(context.getStringValue("sensors_path_input_splitted") == null) {
                            context.sensors_path_input_splitted = null;
                        } else {
                            context.sensors_path_input_splitted=(String) context.getProperty("sensors_path_input_splitted");
                        }
                        context.setContextType("sensors_path_output", "id_Directory");
                        if(context.getStringValue("sensors_path_output") == null) {
                            context.sensors_path_output = null;
                        } else {
                            context.sensors_path_output=(String) context.getProperty("sensors_path_output");
                        }
                        context.setContextType("weather_path_input", "id_Directory");
                        if(context.getStringValue("weather_path_input") == null) {
                            context.weather_path_input = null;
                        } else {
                            context.weather_path_input=(String) context.getProperty("weather_path_input");
                        }
                        context.setContextType("weather_path_input_splitted", "id_Directory");
                        if(context.getStringValue("weather_path_input_splitted") == null) {
                            context.weather_path_input_splitted = null;
                        } else {
                            context.weather_path_input_splitted=(String) context.getProperty("weather_path_input_splitted");
                        }
                        context.setContextType("weather_path_output", "id_Directory");
                        if(context.getStringValue("weather_path_output") == null) {
                            context.weather_path_output = null;
                        } else {
                            context.weather_path_output=(String) context.getProperty("weather_path_output");
                        }
                        context.setContextType("postgresWoneli_AdditionalParams", "id_String");
                        if(context.getStringValue("postgresWoneli_AdditionalParams") == null) {
                            context.postgresWoneli_AdditionalParams = null;
                        } else {
                            context.postgresWoneli_AdditionalParams=(String) context.getProperty("postgresWoneli_AdditionalParams");
                        }
                        context.setContextType("postgresWoneli_Database", "id_String");
                        if(context.getStringValue("postgresWoneli_Database") == null) {
                            context.postgresWoneli_Database = null;
                        } else {
                            context.postgresWoneli_Database=(String) context.getProperty("postgresWoneli_Database");
                        }
                        context.setContextType("postgresWoneli_Login", "id_String");
                        if(context.getStringValue("postgresWoneli_Login") == null) {
                            context.postgresWoneli_Login = null;
                        } else {
                            context.postgresWoneli_Login=(String) context.getProperty("postgresWoneli_Login");
                        }
                        context.setContextType("postgresWoneli_Password", "id_Password");
                        if(context.getStringValue("postgresWoneli_Password") == null) {
                            context.postgresWoneli_Password = null;
                        } else {
                            String pwd_postgresWoneli_Password_value = context.getProperty("postgresWoneli_Password");
                            context.postgresWoneli_Password = null;
                            if(pwd_postgresWoneli_Password_value!=null) {
                                if(context_param.containsKey("postgresWoneli_Password")) {//no need to decrypt if it come from program argument or parent job runtime
                                    context.postgresWoneli_Password = pwd_postgresWoneli_Password_value;
                                } else if (!pwd_postgresWoneli_Password_value.isEmpty()) {
                                    try {
                                        context.postgresWoneli_Password = routines.system.PasswordEncryptUtil.decryptPassword(pwd_postgresWoneli_Password_value);
                                        context.put("postgresWoneli_Password",context.postgresWoneli_Password);
                                    } catch (java.lang.RuntimeException e) {
                                        //do nothing
                                    }
                                }
                            }
                        }
                        context.setContextType("postgresWoneli_Port", "id_String");
                        if(context.getStringValue("postgresWoneli_Port") == null) {
                            context.postgresWoneli_Port = null;
                        } else {
                            context.postgresWoneli_Port=(String) context.getProperty("postgresWoneli_Port");
                        }
                        context.setContextType("postgresWoneli_Schema", "id_String");
                        if(context.getStringValue("postgresWoneli_Schema") == null) {
                            context.postgresWoneli_Schema = null;
                        } else {
                            context.postgresWoneli_Schema=(String) context.getProperty("postgresWoneli_Schema");
                        }
                        context.setContextType("postgresWoneli_Server", "id_String");
                        if(context.getStringValue("postgresWoneli_Server") == null) {
                            context.postgresWoneli_Server = null;
                        } else {
                            context.postgresWoneli_Server=(String) context.getProperty("postgresWoneli_Server");
                        }
                        context.setContextType("endpoinAPI_sensors_currentY", "id_String");
                        if(context.getStringValue("endpoinAPI_sensors_currentY") == null) {
                            context.endpoinAPI_sensors_currentY = null;
                        } else {
                            context.endpoinAPI_sensors_currentY=(String) context.getProperty("endpoinAPI_sensors_currentY");
                        }
                        context.setContextType("endpoinAPI_stations_sensors", "id_String");
                        if(context.getStringValue("endpoinAPI_stations_sensors") == null) {
                            context.endpoinAPI_stations_sensors = null;
                        } else {
                            context.endpoinAPI_stations_sensors=(String) context.getProperty("endpoinAPI_stations_sensors");
                        }
                        context.setContextType("endpoinAPI_stations_weather", "id_String");
                        if(context.getStringValue("endpoinAPI_stations_weather") == null) {
                            context.endpoinAPI_stations_weather = null;
                        } else {
                            context.endpoinAPI_stations_weather=(String) context.getProperty("endpoinAPI_stations_weather");
                        }
                        context.setContextType("endpoinAPI_weather_currentM", "id_String");
                        if(context.getStringValue("endpoinAPI_weather_currentM") == null) {
                            context.endpoinAPI_weather_currentM = null;
                        } else {
                            context.endpoinAPI_weather_currentM=(String) context.getProperty("endpoinAPI_weather_currentM");
                        }
                        context.setContextType("category", "id_String");
                        if(context.getStringValue("category") == null) {
                            context.category = null;
                        } else {
                            context.category=(String) context.getProperty("category");
                        }
                        context.setContextType("csv_to_split", "id_String");
                        if(context.getStringValue("csv_to_split") == null) {
                            context.csv_to_split = null;
                        } else {
                            context.csv_to_split=(String) context.getProperty("csv_to_split");
                        }
                        context.setContextType("duration", "id_Integer");
                        if(context.getStringValue("duration") == null) {
                            context.duration = null;
                        } else {
                            try{
                                context.duration=routines.system.ParserUtils.parseTo_Integer (context.getProperty("duration"));
                            } catch(NumberFormatException e){
                                System.err.println(String.format("Null value will be used for context parameter %s: %s", "duration", e.getMessage()));
                                context.duration=null;
                            }
                        }
                        context.setContextType("num_rows", "id_Integer");
                        if(context.getStringValue("num_rows") == null) {
                            context.num_rows = null;
                        } else {
                            try{
                                context.num_rows=routines.system.ParserUtils.parseTo_Integer (context.getProperty("num_rows"));
                            } catch(NumberFormatException e){
                                System.err.println(String.format("Null value will be used for context parameter %s: %s", "num_rows", e.getMessage()));
                                context.num_rows=null;
                            }
                        }
                        context.setContextType("operation", "id_String");
                        if(context.getStringValue("operation") == null) {
                            context.operation = null;
                        } else {
                            context.operation=(String) context.getProperty("operation");
                        }
                        context.setContextType("table_name", "id_String");
                        if(context.getStringValue("table_name") == null) {
                            context.table_name = null;
                        } else {
                            context.table_name=(String) context.getProperty("table_name");
                        }
                        context.setContextType("truncate", "id_Boolean");
                        if(context.getStringValue("truncate") == null) {
                            context.truncate = null;
                        } else {
                            try{
                                context.truncate=routines.system.ParserUtils.parseTo_Boolean (context.getProperty("truncate"));
                            } catch(NumberFormatException e){
                                System.err.println(String.format("Null value will be used for context parameter %s: %s", "truncate", e.getMessage()));
                                context.truncate=null;
                            }
                        }
                } 
                public void processAllContext() {
                        processContext_0();
                }
            }

            new ContextProcessing().processAllContext();
        } catch (java.io.IOException ie) {
            System.err.println("Could not load context "+contextStr);
            ie.printStackTrace();
        }

        // get context value from parent directly
        if (parentContextMap != null && !parentContextMap.isEmpty()) {if (parentContextMap.containsKey("main_path")) {
                context.main_path = (String) parentContextMap.get("main_path");
            }if (parentContextMap.containsKey("path_bulk")) {
                context.path_bulk = (String) parentContextMap.get("path_bulk");
            }if (parentContextMap.containsKey("path_original")) {
                context.path_original = (String) parentContextMap.get("path_original");
            }if (parentContextMap.containsKey("path_splitted")) {
                context.path_splitted = (String) parentContextMap.get("path_splitted");
            }if (parentContextMap.containsKey("regex_file_to_read")) {
                context.regex_file_to_read = (String) parentContextMap.get("regex_file_to_read");
            }if (parentContextMap.containsKey("sensors_path_input")) {
                context.sensors_path_input = (String) parentContextMap.get("sensors_path_input");
            }if (parentContextMap.containsKey("sensors_path_input_splitted")) {
                context.sensors_path_input_splitted = (String) parentContextMap.get("sensors_path_input_splitted");
            }if (parentContextMap.containsKey("sensors_path_output")) {
                context.sensors_path_output = (String) parentContextMap.get("sensors_path_output");
            }if (parentContextMap.containsKey("weather_path_input")) {
                context.weather_path_input = (String) parentContextMap.get("weather_path_input");
            }if (parentContextMap.containsKey("weather_path_input_splitted")) {
                context.weather_path_input_splitted = (String) parentContextMap.get("weather_path_input_splitted");
            }if (parentContextMap.containsKey("weather_path_output")) {
                context.weather_path_output = (String) parentContextMap.get("weather_path_output");
            }if (parentContextMap.containsKey("postgresWoneli_AdditionalParams")) {
                context.postgresWoneli_AdditionalParams = (String) parentContextMap.get("postgresWoneli_AdditionalParams");
            }if (parentContextMap.containsKey("postgresWoneli_Database")) {
                context.postgresWoneli_Database = (String) parentContextMap.get("postgresWoneli_Database");
            }if (parentContextMap.containsKey("postgresWoneli_Login")) {
                context.postgresWoneli_Login = (String) parentContextMap.get("postgresWoneli_Login");
            }if (parentContextMap.containsKey("postgresWoneli_Password")) {
                context.postgresWoneli_Password = (java.lang.String) parentContextMap.get("postgresWoneli_Password");
            }if (parentContextMap.containsKey("postgresWoneli_Port")) {
                context.postgresWoneli_Port = (String) parentContextMap.get("postgresWoneli_Port");
            }if (parentContextMap.containsKey("postgresWoneli_Schema")) {
                context.postgresWoneli_Schema = (String) parentContextMap.get("postgresWoneli_Schema");
            }if (parentContextMap.containsKey("postgresWoneli_Server")) {
                context.postgresWoneli_Server = (String) parentContextMap.get("postgresWoneli_Server");
            }if (parentContextMap.containsKey("endpoinAPI_sensors_currentY")) {
                context.endpoinAPI_sensors_currentY = (String) parentContextMap.get("endpoinAPI_sensors_currentY");
            }if (parentContextMap.containsKey("endpoinAPI_stations_sensors")) {
                context.endpoinAPI_stations_sensors = (String) parentContextMap.get("endpoinAPI_stations_sensors");
            }if (parentContextMap.containsKey("endpoinAPI_stations_weather")) {
                context.endpoinAPI_stations_weather = (String) parentContextMap.get("endpoinAPI_stations_weather");
            }if (parentContextMap.containsKey("endpoinAPI_weather_currentM")) {
                context.endpoinAPI_weather_currentM = (String) parentContextMap.get("endpoinAPI_weather_currentM");
            }if (parentContextMap.containsKey("category")) {
                context.category = (String) parentContextMap.get("category");
            }if (parentContextMap.containsKey("csv_to_split")) {
                context.csv_to_split = (String) parentContextMap.get("csv_to_split");
            }if (parentContextMap.containsKey("duration")) {
                context.duration = (Integer) parentContextMap.get("duration");
            }if (parentContextMap.containsKey("num_rows")) {
                context.num_rows = (Integer) parentContextMap.get("num_rows");
            }if (parentContextMap.containsKey("operation")) {
                context.operation = (String) parentContextMap.get("operation");
            }if (parentContextMap.containsKey("table_name")) {
                context.table_name = (String) parentContextMap.get("table_name");
            }if (parentContextMap.containsKey("truncate")) {
                context.truncate = (Boolean) parentContextMap.get("truncate");
            }
        }

        //Resume: init the resumeUtil
        resumeEntryMethodName = ResumeUtil.getResumeEntryMethodName(resuming_checkpoint_path);
        resumeUtil = new ResumeUtil(resuming_logs_dir_path, isChildJob, rootPid);
        resumeUtil.initCommonInfo(pid, rootPid, fatherPid, projectName, jobName, contextStr, jobVersion);

		List<String> parametersToEncrypt = new java.util.ArrayList<String>();
			parametersToEncrypt.add("postgresWoneli_Password");
        //Resume: jobStart
        resumeUtil.addLog("JOB_STARTED", "JOB:" + jobName, parent_part_launcher, Thread.currentThread().getId() + "", "","","","",resumeUtil.convertToJsonText(context,parametersToEncrypt));

if(execStat) {
    try {
        runStat.openSocket(!isChildJob);
        runStat.setAllPID(rootPid, fatherPid, pid, jobName);
        runStat.startThreadStat(clientHost, portStats);
        runStat.updateStatOnJob(RunStat.JOBSTART, fatherNode);
    } catch (java.io.IOException ioException) {
        ioException.printStackTrace();
    }
}



	
	    java.util.concurrent.ConcurrentHashMap<Object, Object> concurrentHashMap = new java.util.concurrent.ConcurrentHashMap<Object, Object>();
	    globalMap.put("concurrentHashMap", concurrentHashMap);
	

    long startUsedMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
    long endUsedMemory = 0;
    long end = 0;

    startTime = System.currentTimeMillis();


this.globalResumeTicket = true;//to run tPreJob





this.globalResumeTicket = false;//to run others jobs

try {
errorCode = null;tFileList_1Process(globalMap);
if(!"failure".equals(status)) { status = "end"; }
}catch (TalendException e_tFileList_1) {
globalMap.put("tFileList_1_SUBPROCESS_STATE", -1);

e_tFileList_1.printStackTrace();

}

this.globalResumeTicket = true;//to run tPostJob




        end = System.currentTimeMillis();

        if (watch) {
            System.out.println((end-startTime)+" milliseconds");
        }

        endUsedMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
        if (false) {
            System.out.println((endUsedMemory - startUsedMemory) + " bytes memory increase when running : combineSplittedCsv");
        }



if (execStat) {
    runStat.updateStatOnJob(RunStat.JOBEND, fatherNode);
    runStat.stopThreadStat();
}
    int returnCode = 0;


    if(errorCode == null) {
         returnCode = status != null && status.equals("failure") ? 1 : 0;
    } else {
         returnCode = errorCode.intValue();
    }
    resumeUtil.addLog("JOB_ENDED", "JOB:" + jobName, parent_part_launcher, Thread.currentThread().getId() + "", "","" + returnCode,"","","");

    return returnCode;

  }

    // only for OSGi env
    public void destroy() {


    }














    private java.util.Map<String, Object> getSharedConnections4REST() {
        java.util.Map<String, Object> connections = new java.util.HashMap<String, Object>();






        return connections;
    }

    private void evalParam(String arg) {
        if (arg.startsWith("--resuming_logs_dir_path")) {
            resuming_logs_dir_path = arg.substring(25);
        } else if (arg.startsWith("--resuming_checkpoint_path")) {
            resuming_checkpoint_path = arg.substring(27);
        } else if (arg.startsWith("--parent_part_launcher")) {
            parent_part_launcher = arg.substring(23);
        } else if (arg.startsWith("--watch")) {
            watch = true;
        } else if (arg.startsWith("--stat_port=")) {
            String portStatsStr = arg.substring(12);
            if (portStatsStr != null && !portStatsStr.equals("null")) {
                portStats = Integer.parseInt(portStatsStr);
            }
        } else if (arg.startsWith("--trace_port=")) {
            portTraces = Integer.parseInt(arg.substring(13));
        } else if (arg.startsWith("--client_host=")) {
            clientHost = arg.substring(14);
        } else if (arg.startsWith("--context=")) {
            contextStr = arg.substring(10);
            isDefaultContext = false;
        } else if (arg.startsWith("--father_pid=")) {
            fatherPid = arg.substring(13);
        } else if (arg.startsWith("--root_pid=")) {
            rootPid = arg.substring(11);
        } else if (arg.startsWith("--father_node=")) {
            fatherNode = arg.substring(14);
        } else if (arg.startsWith("--pid=")) {
            pid = arg.substring(6);
        } else if (arg.startsWith("--context_type")) {
            String keyValue = arg.substring(15);
			int index = -1;
            if (keyValue != null && (index = keyValue.indexOf('=')) > -1) {
                if (fatherPid==null) {
                    context_param.setContextType(keyValue.substring(0, index), replaceEscapeChars(keyValue.substring(index + 1)));
                } else { // the subjob won't escape the especial chars
                    context_param.setContextType(keyValue.substring(0, index), keyValue.substring(index + 1) );
                }

            }

		} else if (arg.startsWith("--context_param")) {
            String keyValue = arg.substring(16);
            int index = -1;
            if (keyValue != null && (index = keyValue.indexOf('=')) > -1) {
                if (fatherPid==null) {
                    context_param.put(keyValue.substring(0, index), replaceEscapeChars(keyValue.substring(index + 1)));
                } else { // the subjob won't escape the especial chars
                    context_param.put(keyValue.substring(0, index), keyValue.substring(index + 1) );
                }
            }
        } else if (arg.startsWith("--log4jLevel=")) {
            log4jLevel = arg.substring(13);
		} else if (arg.startsWith("--audit.enabled") && arg.contains("=")) {//for trunjob call
		    final int equal = arg.indexOf('=');
			final String key = arg.substring("--".length(), equal);
			System.setProperty(key, arg.substring(equal + 1));
		}
    }
    
    private static final String NULL_VALUE_EXPRESSION_IN_COMMAND_STRING_FOR_CHILD_JOB_ONLY = "<TALEND_NULL>";

    private final String[][] escapeChars = {
        {"\\\\","\\"},{"\\n","\n"},{"\\'","\'"},{"\\r","\r"},
        {"\\f","\f"},{"\\b","\b"},{"\\t","\t"}
        };
    private String replaceEscapeChars (String keyValue) {

		if (keyValue == null || ("").equals(keyValue.trim())) {
			return keyValue;
		}

		StringBuilder result = new StringBuilder();
		int currIndex = 0;
		while (currIndex < keyValue.length()) {
			int index = -1;
			// judege if the left string includes escape chars
			for (String[] strArray : escapeChars) {
				index = keyValue.indexOf(strArray[0],currIndex);
				if (index>=0) {

					result.append(keyValue.substring(currIndex, index + strArray[0].length()).replace(strArray[0], strArray[1]));
					currIndex = index + strArray[0].length();
					break;
				}
			}
			// if the left string doesn't include escape chars, append the left into the result
			if (index < 0) {
				result.append(keyValue.substring(currIndex));
				currIndex = currIndex + keyValue.length();
			}
		}

		return result.toString();
    }

    public Integer getErrorCode() {
        return errorCode;
    }


    public String getStatus() {
        return status;
    }

    ResumeUtil resumeUtil = null;
}
/************************************************************************************************
 *     84315 characters generated by Talend Open Studio for Data Integration 
 *     on the November 8, 2022 at 9:05:17 AM CET
 ************************************************************************************************/